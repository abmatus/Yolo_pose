<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>AI Vision Pro</title>
    <link rel="manifest" href="manifest.json">
    
    <!-- TensorFlow.js Libraries -->
    <!-- WICHTIG: Die Reihenfolge ist entscheidend. Core -> Converter -> Backends -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    
    <!-- Backend CPU: Zwingend erforderlich für Coco-SSD Post-Processing! -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-cpu"></script>
    <!-- Backend WebGL: Für schnelle GPU-Berechnung -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    
    <!-- Models -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>

    <style>
        :root {
            --accent: #FFD60A; /* Cyber Yellow */
            --bg-glass: rgba(0, 0, 0, 0.4);
            --text-active: #ffffff;
            --text-inactive: rgba(255, 255, 255, 0.5);
            --safe-top: env(safe-area-inset-top, 20px);
            --safe-bottom: env(safe-area-inset-bottom, 20px);
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body { 
            margin: 0; background: #000; overflow: hidden; height: 100vh; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            user-select: none;
            touch-action: manipulation;
        }

        /* --- Fullscreen Viewfinder --- */
        #view-container { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: #000; z-index: 1;
        }
        
        video { 
            width: 100%; height: 100%; object-fit: cover; 
            transform: scale(1.0); transition: transform 0.3s;
        }
        
        canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover; pointer-events: none;
        }

        /* --- Flash Overlay Effect --- */
        #flash-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white; opacity: 0; pointer-events: none; z-index: 100;
            transition: opacity 0.1s ease-out;
        }

        /* --- HUD Layer --- */
        #hud {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between;
            pointer-events: none; /* Klicks gehen durch */
        }

        /* Top Bar */
        .top-controls {
            padding: calc(var(--safe-top) + 10px) 20px 0;
            display: flex; justify-content: space-between; align-items: center;
            pointer-events: auto;
        }

        .icon-btn {
            background: rgba(0,0,0,0.3); backdrop-filter: blur(10px);
            border: none; border-radius: 50%; width: 44px; height: 44px;
            display: flex; align-items: center; justify-content: center;
            color: white; cursor: pointer; transition: 0.2s;
        }
        .icon-btn:active { transform: scale(0.9); background: rgba(255,255,255,0.2); }
        .icon-btn svg { width: 24px; height: 24px; fill: white; }

        #fps-badge {
            font-size: 12px; font-weight: 700; color: var(--accent);
            background: rgba(0,0,0,0.5); padding: 4px 8px; border-radius: 4px;
            font-family: monospace; letter-spacing: 1px;
        }

        /* Bottom Controls */
        .bottom-controls {
            padding-bottom: calc(var(--safe-bottom) + 30px);
            background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, transparent 100%);
            display: flex; flex-direction: column; align-items: center; gap: 20px;
            pointer-events: auto;
        }

        /* Mode Selector (Text Slider style) */
        .mode-selector {
            display: flex; gap: 30px; margin-bottom: 10px;
        }
        .mode-item {
            font-size: 13px; font-weight: 600; letter-spacing: 1px;
            color: var(--text-inactive); text-transform: uppercase;
            cursor: pointer; transition: 0.3s; padding: 5px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        .mode-item.active {
            color: var(--accent); transform: scale(1.1);
        }

        /* Shutter Area */
        .shutter-row {
            display: flex; align-items: center; justify-content: center; width: 100%;
            position: relative;
        }

        .shutter-btn {
            width: 80px; height: 80px; border-radius: 50%;
            border: 4px solid white; background: transparent;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: 0.2s; z-index: 20;
        }
        .shutter-inner {
            width: 68px; height: 68px; border-radius: 50%; background: white;
            transition: 0.2s;
        }
        .shutter-btn:active .shutter-inner { transform: scale(0.9); opacity: 0.8; }

        /* Switch Cam Button (rechts vom Shutter) */
        .switch-btn-container {
            position: absolute; right: 40px;
        }

        /* Loading Screen */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 200; display: flex; flex-direction: column;
            justify-content: center; align-items: center; transition: opacity 0.5s;
        }
        .spinner {
            width: 50px; height: 50px; border: 3px solid rgba(255,255,255,0.1);
            border-top-color: var(--accent); border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .loader-text { margin-top: 20px; color: #666; font-size: 12px; letter-spacing: 2px; }

    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text">AI MODULE LOADING</div>
    </div>

    <!-- Viewfinder -->
    <div id="view-container">
        <video id="video" playsinline muted autoplay></video>
        <canvas id="output"></canvas>
    </div>
    
    <!-- Flash Animation -->
    <div id="flash-overlay"></div>

    <!-- UI Overlay -->
    <div id="hud">
        
        <!-- Top Bar -->
        <div class="top-controls">
            <button class="icon-btn" id="btn-flash">
                <!-- Flash Icon (Off) -->
                <svg id="icon-flash-off" viewBox="0 0 24 24"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg>
            </button>
            <div id="fps-badge">AI READY</div>
            <button class="icon-btn" id="btn-info">
                <!-- Info Icon -->
                <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/></svg>
            </button>
        </div>

        <!-- Bottom Bar -->
        <div class="bottom-controls">
            
            <!-- Mode Selector -->
            <div class="mode-selector">
                <div class="mode-item active" data-mode="pose">BODY POSE</div>
                <div class="mode-item" data-mode="object">OBJECTS</div>
            </div>

            <!-- Shutter Row -->
            <div class="shutter-row">
                <div class="shutter-btn" id="btn-shutter">
                    <div class="shutter-inner"></div>
                </div>

                <div class="switch-btn-container">
                    <button class="icon-btn" id="btn-switch-cam" style="background: rgba(255,255,255,0.1);">
                        <svg viewBox="0 0 24 24"><path d="M20 4h-3.17L15 2H9L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-5 11.5V13H9v2.5L5.5 12 9 8.5V11h6V8.5l3.5 3.5-3.5 3.5z"/></svg>
                    </button>
                </div>
            </div>

        </div>
    </div>

    <script>
        // PWA Helper mit erweiterter Überprüfung für Service Worker in Dev-Umgebungen
        if ('serviceWorker' in navigator && (window.location.protocol.indexOf('http') === 0)) {
            navigator.serviceWorker.register('./sw.js')
                .then(reg => console.log('Service Worker registriert'))
                .catch(err => console.log('Service Worker übersprungen (Dev Mode):', err));
        }

        // --- Elements ---
        const video = document.getElementById('video');
        const canvas = document.getElementById('output');
        const ctx = canvas.getContext('2d');
        const loader = document.getElementById('loader');
        const flashOverlay = document.getElementById('flash-overlay');
        const fpsBadge = document.getElementById('fps-badge');
        
        // Buttons
        const modeItems = document.querySelectorAll('.mode-item');
        const shutterBtn = document.getElementById('btn-shutter');
        const switchBtn = document.getElementById('btn-switch-cam');
        const flashBtn = document.getElementById('btn-flash');
        const viewContainer = document.getElementById('view-container');

        // State
        let detector;
        let currentModel = 'pose';
        let facingMode = 'environment';
        let currentStream = null;
        let lastFrameTime = 0;
        let torchOn = false;

        // --- Initialization ---
        async function init() {
            // WICHTIG: WebGL Backend ist Standard, aber CPU muss verfügbar sein
            await tf.setBackend('webgl');
            
            // Erst Kamera starten
            await setupCamera();
            
            // Dann Modell laden (während Kamera schon läuft)
            loadModel('pose'); 
        }

        // --- Camera & Torch ---
        async function setupCamera() {
            if (currentStream) {
                currentStream.getTracks().forEach(t => t.stop());
            }

            const constraints = {
                video: {
                    facingMode: facingMode,
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                },
                audio: false
            };

            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                currentStream = stream;
                video.srcObject = stream;

                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        resolve();
                    };
                });
            } catch (err) {
                console.error("Camera fail", err);
                // Nur warnen wenn nicht im Iframe, um unnötige Alerts in der Vorschau zu vermeiden
                if (window.self === window.top) {
                   alert("Kamera-Zugriff verweigert oder nicht verfügbar.");
                }
            }
        }

        async function toggleTorch() {
            if (!currentStream) return;
            const track = currentStream.getVideoTracks()[0];
            const capabilities = track.getCapabilities ? track.getCapabilities() : {};

            if (capabilities.torch) {
                torchOn = !torchOn;
                try {
                    await track.applyConstraints({
                        advanced: [{ torch: torchOn }]
                    });
                    
                    // UI Update
                    flashBtn.style.color = torchOn ? '#FFD60A' : 'white';
                    flashBtn.style.background = torchOn ? 'rgba(255, 214, 10, 0.2)' : 'rgba(0,0,0,0.3)';
                } catch(e) { console.error("Torch error:", e); }
            } else {
                alert("Blitz nicht verfügbar auf diesem Gerät/Kamera.");
            }
        }

        // --- AI Models ---
        async function loadModel(type) {
            currentModel = type;
            fpsBadge.innerText = "LOADING AI...";
            fpsBadge.style.color = "white";

            if (detector) {
                if(detector.dispose) detector.dispose();
                detector = null;
            }

            // Kurze Pause für UI Render
            await new Promise(r => setTimeout(r, 50));

            try {
                if (type === 'pose') {
                    const model = poseDetection.SupportedModels.MoveNet;
                    detector = await poseDetection.createDetector(model, {
                        modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING
                    });
                } else {
                    // CocoSSD lädt intern, benötigt aber das nun eingebundene CPU-Backend
                    detector = await cocoSsd.load();
                }

                // Loader verstecken wenn erstes Modell fertig
                if(loader.style.display !== 'none') {
                    loader.style.opacity = 0;
                    setTimeout(() => loader.style.display = 'none', 500);
                }
                
                render();
            } catch (err) {
                console.error("AI Loading Error:", err);
                fpsBadge.innerText = "ERROR";
                alert("Fehler beim Laden: " + err.message);
            }
        }

        // --- Render Loop ---
        async function render() {
            if (!detector) return;

            const now = performance.now();
            if(now - lastFrameTime > 500) { // Update FPS every 500ms
                 const fps = Math.round(1000 / (now - lastFrameTime));
                 fpsBadge.innerText = currentModel === 'pose' ? 'ACTIVE: POSE' : 'ACTIVE: OBJECT';
                 fpsBadge.style.color = 'var(--accent)';
            }
            lastFrameTime = now;

            if (video.readyState === 4) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                try {
                    if (currentModel === 'pose') {
                        const poses = await detector.estimatePoses(video);
                        if (poses.length > 0) drawPose(poses[0].keypoints);
                    } else {
                        const predictions = await detector.detect(video);
                        drawObjects(predictions);
                    }
                } catch(e) { 
                    console.warn("Inference error:", e); 
                }
            }
            requestAnimationFrame(render);
        }

        // --- Drawing (Modern Neon Style) ---
        function drawPose(keypoints) {
            const minConf = 0.3;
            const connections = poseDetection.util.getAdjacentPairs(poseDetection.SupportedModels.MoveNet);
            
            ctx.shadowColor = '#FFD60A';
            ctx.shadowBlur = 10;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Lines
            ctx.lineWidth = 4;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            connections.forEach(([i, j]) => {
                const kp1 = keypoints[i];
                const kp2 = keypoints[j];
                if (kp1.score > minConf && kp2.score > minConf) {
                    ctx.beginPath();
                    ctx.moveTo(kp1.x, kp1.y);
                    ctx.lineTo(kp2.x, kp2.y);
                    ctx.stroke();
                }
            });

            // Joints
            ctx.fillStyle = '#FFD60A'; // Neon Yellow
            keypoints.forEach(kp => {
                if (kp.score > minConf) {
                    ctx.beginPath();
                    ctx.arc(kp.x, kp.y, 6, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
            ctx.shadowBlur = 0;
        }

        function drawObjects(predictions) {
            ctx.shadowColor = '#00E5FF';
            ctx.shadowBlur = 15;
            
            predictions.forEach(p => {
                const [x, y, w, h] = p.bbox;
                
                // Fancy Corners Only instead of full box (Futuristic look)
                const lineLen = Math.min(w, h) / 4;
                ctx.lineWidth = 4;
                ctx.strokeStyle = '#00E5FF'; // Cyber Blue

                ctx.beginPath();
                // Top Left
                ctx.moveTo(x, y + lineLen); ctx.lineTo(x, y); ctx.lineTo(x + lineLen, y);
                // Top Right
                ctx.moveTo(x + w - lineLen, y); ctx.lineTo(x + w, y); ctx.lineTo(x + w, y + lineLen);
                // Bottom Right
                ctx.moveTo(x + w, y + h - lineLen); ctx.lineTo(x + w, y + h); ctx.lineTo(x + w - lineLen, y + h);
                // Bottom Left
                ctx.moveTo(x + lineLen, y + h); ctx.lineTo(x, y + h); ctx.lineTo(x, y + h - lineLen);
                ctx.stroke();

                // Text
                ctx.font = 'bold 16px Courier New';
                ctx.fillStyle = '#00E5FF';
                ctx.fillText(`${p.class.toUpperCase()} ${Math.round(p.score*100)}%`, x + 5, y - 10);
            });
            ctx.shadowBlur = 0;
        }

        // --- Interaction Handlers ---

        // Switch Mode
        modeItems.forEach(item => {
            item.addEventListener('click', (e) => {
                const mode = e.target.dataset.mode;
                if(mode === currentModel) return;

                // UI Update
                modeItems.forEach(i => i.classList.remove('active'));
                e.target.classList.add('active');

                // Logic
                loadModel(mode);
                if(navigator.vibrate) navigator.vibrate(20);
            });
        });

        // Double Tap to switch cam
        let lastTap = 0;
        viewContainer.addEventListener('touchstart', (e) => {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTap;
            if (tapLength < 300 && tapLength > 0) {
                switchCamera();
                e.preventDefault();
            }
            lastTap = currentTime;
        });

        switchBtn.addEventListener('click', switchCamera);
        
        async function switchCamera() {
            if(navigator.vibrate) navigator.vibrate(30);
            
            // Flip Animation
            video.style.transform = "scale(0.1)";
            setTimeout(() => video.style.transform = "scale(1.0)", 400);

            facingMode = facingMode === 'environment' ? 'user' : 'environment';
            await setupCamera();
        }

        flashBtn.addEventListener('click', toggleTorch);

        shutterBtn.addEventListener('click', () => {
            if(navigator.vibrate) navigator.vibrate(50);
            
            // Flash Effect
            flashOverlay.style.opacity = 1;
            setTimeout(() => flashOverlay.style.opacity = 0, 150);

            // Save Image
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tCtx = tempCanvas.getContext('2d');
            tCtx.drawImage(video, 0, 0, canvas.width, canvas.height);
            tCtx.drawImage(canvas, 0, 0); // Overlay drauf

            const link = document.createElement('a');
            link.download = `VISION-AI-${Date.now()}.png`;
            link.href = tempCanvas.toDataURL('image/png');
            link.click();
        });

        // Start
        init();

    </script>
</body>
</html>
