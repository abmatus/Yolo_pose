<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>AI Vision</title>
    <link rel="manifest" href="manifest.json">
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>

    <style>
        :root {
            --accent: #32D74B; /* iOS Green */
            --glass: rgba(28, 28, 30, 0.65);
            --glass-border: rgba(255, 255, 255, 0.1);
            --text: #ffffff;
            --safe-top: env(safe-area-inset-top, 20px);
            --safe-bottom: env(safe-area-inset-bottom, 20px);
        }

        body { 
            margin: 0; background: #000; overflow: hidden; height: 100vh; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        /* --- Layers --- */
        #view-container { position: relative; width: 100%; height: 100%; display: flex; justify-content: center; background: #000;}
        
        video { position: absolute; height: 100%; width: 100%; object-fit: cover; }
        canvas { position: absolute; height: 100%; width: 100%; object-fit: cover; }

        /* Flash Effekt für Snapshot */
        #flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white; opacity: 0; pointer-events: none; z-index: 50;
            transition: opacity 0.1s;
        }

        /* --- UI Overlay --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20;
            display: flex; flex-direction: column; justify-content: space-between;
            pointer-events: none;
        }

        /* --- Header / Segmented Control --- */
        .header {
            padding-top: calc(var(--safe-top) + 10px);
            display: flex; justify-content: center;
            pointer-events: auto;
        }

        .segmented-control {
            background: var(--glass);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            padding: 4px; border-radius: 100px;
            display: flex; gap: 5px;
            border: 1px solid var(--glass-border);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .seg-btn {
            background: transparent; border: none; color: rgba(255,255,255,0.6);
            padding: 8px 20px; border-radius: 100px; font-weight: 600; font-size: 13px;
            cursor: pointer; transition: 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        .seg-btn.active {
            background: rgba(255,255,255,0.15); color: #fff;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        /* --- Footer Controls --- */
        .footer {
            padding-bottom: calc(var(--safe-bottom) + 30px);
            display: flex; justify-content: center; align-items: center; gap: 40px;
            pointer-events: auto;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
        }

        .control-btn {
            width: 45px; height: 45px; border-radius: 50%;
            background: var(--glass); backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            color: white; display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: transform 0.1s;
        }
        .control-btn:active { transform: scale(0.9); background: rgba(255,255,255,0.2); }
        .control-btn svg { width: 20px; height: 20px; fill: currentColor; }

        /* Shutter Button */
        #shutter-btn {
            width: 72px; height: 72px; border-radius: 50%;
            background: transparent; border: 4px solid white;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
        }
        #shutter-inner {
            width: 60px; height: 60px; border-radius: 50%; background: white;
            transition: 0.2s;
        }
        #shutter-btn:active #shutter-inner { transform: scale(0.85); opacity: 0.8; }

        /* FPS Pill */
        #fps-pill {
            position: absolute; top: calc(var(--safe-top) + 20px); right: 20px;
            background: rgba(0,0,0,0.5); color: rgba(255,255,255,0.8);
            padding: 4px 8px; border-radius: 6px; font-size: 10px; font-family: monospace;
            pointer-events: none; backdrop-filter: blur(5px);
        }

        /* --- Loading Screen --- */
        #splash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100; display: flex; flex-direction: column;
            justify-content: center; align-items: center; transition: opacity 0.5s;
        }
        .loader-ring {
            width: 40px; height: 40px; border: 3px solid rgba(255,255,255,0.1);
            border-top: 3px solid var(--accent); border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        .splash-text { font-size: 14px; color: #666; font-weight: 500; letter-spacing: 0.5px; }

    </style>
</head>
<body>

    <div id="splash">
        <div class="loader-ring"></div>
        <div class="splash-text">INITIALIZING AI CORE</div>
    </div>

    <div id="view-container">
        <video id="video" playsinline muted autoplay></video>
        <canvas id="output"></canvas>
        <div id="flash"></div>
    </div>

    <div id="ui-layer">
        
        <div class="header">
            <div class="segmented-control">
                <button class="seg-btn active" data-model="pose">Pose</button>
                <button class="seg-btn" data-model="object">Object</button>
            </div>
        </div>

        <div id="fps-pill">FPS: 0</div>

        <div class="footer">
            <div class="control-btn" id="btn-switch">
                <svg viewBox="0 0 24 24"><path d="M20 4h-3.17L15 2H9L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-5 11.5V13H9v2.5L5.5 12 9 8.5V11h6V8.5l3.5 3.5-3.5 3.5z"/></svg>
            </div>

            <div id="shutter-btn">
                <div id="shutter-inner"></div>
            </div>

            <div class="control-btn" id="btn-info" style="opacity:0.5;"> <svg viewBox="0 0 24 24"><path d="M11 17h2v-6h-2v6zm1-15C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zM11 9h2V7h-2v2z"/></svg>
            </div>
        </div>
    </div>

    <script>
        // PWA Setup
        if ('serviceWorker' in navigator) navigator.serviceWorker.register('./sw.js');

        // Elements
        const video = document.getElementById('video');
        const canvas = document.getElementById('output');
        const ctx = canvas.getContext('2d');
        const splash = document.getElementById('splash');
        const fpsPill = document.getElementById('fps-pill');
        const flash = document.getElementById('flash');
        
        // Buttons
        const segBtns = document.querySelectorAll('.seg-btn');
        const switchBtn = document.getElementById('btn-switch');
        const shutterBtn = document.getElementById('shutter-btn');

        // State
        let detector;
        let currentModel = 'pose';
        let facingMode = 'environment';
        let currentStream = null;
        let lastFrameTime = 0;
        let frameCount = 0;

        // --- Core Logic ---

        async function init() {
            await tf.setBackend('webgl');
            await setupCamera();
            await loadModel('pose');
            
            // UI Ready
            splash.style.opacity = '0';
            setTimeout(() => splash.style.display = 'none', 500);
            render();
        }

        async function setupCamera() {
            if (currentStream) currentStream.getTracks().forEach(t => t.stop());
            
            const constraints = {
                video: {
                    facingMode: facingMode,
                    width: { ideal: 1280 }, // HD Auflösung
                    height: { ideal: 720 }
                },
                audio: false
            };

            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                currentStream = stream;
                video.srcObject = stream;
                
                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        resolve();
                    };
                });
            } catch (err) {
                console.error(err);
                alert('Kamera konnte nicht gestartet werden.');
            }
        }

        async function loadModel(type) {
            currentModel = type;
            
            // Haptik Feedback
            if(navigator.vibrate) navigator.vibrate(20);

            if(detector) {
                if(detector.dispose) detector.dispose();
                detector = null;
            }

            if (type === 'pose') {
                const model = poseDetection.SupportedModels.MoveNet;
                detector = await poseDetection.createDetector(model, {
                    modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING
                });
            } else {
                detector = await cocoSsd.load();
            }
        }

        // --- Rendering ---

        async function render() {
            const now = performance.now();
            if(now - lastFrameTime >= 1000) {
               // Simple FPS counter
               // fpsPill.innerText = `FPS: ${Math.round(1000 / (now - lastFrameTime))}`; 
            }
            lastFrameTime = now;

            if (video.readyState === 4 && detector) {
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Nur AI zeichnen, Video ist Hintergrund
                
                // Wir zeichnen das Video NICHT auf den Canvas, um Performance zu sparen.
                // Das Video Element liegt dahinter. Wir zeichnen nur die Overlays.
                
                try {
                    if (currentModel === 'pose') {
                        const poses = await detector.estimatePoses(video);
                        if (poses.length > 0) drawPose(poses[0].keypoints);
                    } else {
                        const predictions = await detector.detect(video);
                        drawObjects(predictions);
                    }
                } catch(e) { console.log(e); }
            }
            requestAnimationFrame(render);
        }

        // --- Drawing Helpers (Modern Style) ---

        function drawPose(keypoints) {
            const minConf = 0.3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Verbindungen
            const connections = poseDetection.util.getAdjacentPairs(poseDetection.SupportedModels.MoveNet);
            ctx.lineWidth = 4;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; // Weisse Linien
            
            connections.forEach(([i, j]) => {
                const kp1 = keypoints[i];
                const kp2 = keypoints[j];
                if (kp1.score > minConf && kp2.score > minConf) {
                    ctx.beginPath();
                    ctx.moveTo(kp1.x, kp1.y);
                    ctx.lineTo(kp2.x, kp2.y);
                    ctx.stroke();
                }
            });

            // Punkte (Joints)
            keypoints.forEach(kp => {
                if (kp.score > minConf) {
                    ctx.beginPath();
                    ctx.arc(kp.x, kp.y, 6, 0, 2 * Math.PI);
                    ctx.fillStyle = '#32D74B'; // iOS Green
                    ctx.fill();
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#fff';
                    ctx.stroke();
                }
            });
        }

        function drawObjects(predictions) {
            predictions.forEach(p => {
                const [x, y, w, h] = p.bbox;
                const conf = Math.round(p.score * 100);
                
                // Moderne Bounding Box: Runde Ecken, dünne Linie
                ctx.strokeStyle = 'rgba(50, 215, 75, 0.8)';
                ctx.lineWidth = 3;
                roundRect(ctx, x, y, w, h, 10); // Custom function for rounded rects
                ctx.stroke();

                // Label Pill
                ctx.fillStyle = 'rgba(50, 215, 75, 1)';
                const text = `${p.class} ${conf}%`;
                const textWidth = ctx.measureText(text).width;
                
                ctx.beginPath();
                ctx.roundRect(x, y - 26, textWidth + 16, 22, 6);
                ctx.fill();

                ctx.fillStyle = '#000';
                ctx.font = '600 12px -apple-system, sans-serif';
                ctx.fillText(text, x + 8, y - 10);
            });
        }

        function roundRect(ctx, x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
        }

        // --- Interactions ---

        // Model Switcher
        segBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                segBtns.forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                loadModel(e.target.dataset.model);
            });
        });

        // Switch Camera
        switchBtn.addEventListener('click', () => {
            if(navigator.vibrate) navigator.vibrate(10);
            facingMode = facingMode === 'environment' ? 'user' : 'environment';
            setupCamera();
        });

        // Snapshot
        shutterBtn.addEventListener('click', () => {
            if(navigator.vibrate) navigator.vibrate(50);
            
            // Flash Animation
            flash.style.opacity = '0.8';
            setTimeout(() => flash.style.opacity = '0', 100);

            // Screenshot Logic
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // 1. Video Frame zeichnen
            tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
            // 2. Overlay zeichnen
            tempCtx.drawImage(canvas, 0, 0);

            // 3. Download
            const link = document.createElement('a');
            link.download = `ai-shot-${Date.now()}.png`;
            link.href = tempCanvas.toDataURL('image/png');
            link.click();
        });

        init();

    </script>
</body>
</html>
